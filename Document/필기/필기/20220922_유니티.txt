유니티에서 싱글톤 쓸 때
monobehavior 를 상속받는 놈은 new로 생성을 할 수 없다.
Awake 에서 this 로 instance에 개체 지정하고, 
프로퍼티에서는 if(instance == null) return null 로 처리하기


아이템, 스킬을 쓸 때
사용자/적용 대상이 같은경우, 다른경우가 있기 때문에, 플레이어매니저가 게임매니저에 넘겨줄 때 자신 + 적용대상 까지 한번에 넘겨준다.
그걸 받아서 사용할지 말지는 이제 나중에 각각 아이템,스킬 이 알아서 할 문제.


아이템(스킬)이 상대방에게 효과를 줄 때 아이템에서 직접 변수에 접근하지 말고 
그 대상에 자기자신의 변수를 수정하는 함수를 만들어두고,
아이템(스킬)이 그 함수를 호출하는식으로 한다.



트리거 관리할 때 
웬만하면 On Off 따로 만들기
토글이 필요한 경우, 토글을 하나 더 만들어서 세개를 만들자


>>>>>>>>>>>>>>>>>>>>>>
GameManager 를 독립적인 대가리로 수정할 것  0000000

플레이어, 플레이어 매니저 나누기   000000000

워프게이트 등 다른것도 매니저로 관리할 것


싱글톤 제대로 구현하기
정적변수로 접근하는거 있는지 찾아보고 고치기


플레이어 하나 더 추가해보기
1 누르면 빨공, 2누르면 파공 컨트롤할 수 있게 하기
(4p 까지 확장성 고려할 것)



아이템 먹으면 없어지고 다시 생성되게 하기
아이템매니저 쓸데없는거 지우기
아이템타입 이름 바꾸기




>>>>>>>>>>>>>>>>>>>>>>>>>

매니저는 실체 하나만 있으면 되니까
인스팩터에 붙이는 방식 말고 GameManager 에서 생성하는 방식은 어떨까?

게임매니저는 각각 매니저를 인스팩터에 붙이든 생성하든 할 수 있다.
그런데 하위매니저가 게임매니저를 받는 방법이나 or
하위 객체가 각각 매니저에 연결을 할때는 인스팩터에 붙이는 방법이 제일 좋은가? Find는 너무 무리가 있을것 같고 새로 생성하는건 아닌것 같음.

monobehavior 를 상속받는 클래스들은 new 로 동적할당이 안되니까
생성자 호출도 원래 못하는거 아닐까? 
그럼 private 생성자 (){} 를 할 필요가 있는가?