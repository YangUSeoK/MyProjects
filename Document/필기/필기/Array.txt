오후 2:13 2022-08-02

평생 공부를 해야하는 직업, 압박감

왜 개발자를 선택했는가
어떤 개발자가 되고싶은가
그것을 위해 이때까지 어떤 것들을 해왔는가

구체적인 목표설정 필요

블로그에 내용 보기
게임관련 자료구조와 알고리즘 한글pdf 
=============================

자료구조/알고리즘 = 코테, 기술면접 90%
자료구조 : 데이터를 어떻게 읽고 쓸 것인가(관리)
알고리즘 : 저장된 데이터를 어떻게 효율적으로 사용할 것인가(활용)



========================
for에서 쓰이는 i 변수는 Index 에서 따왔다는 설이 있을 정도로 배열과 반복문은 잘어울린다.

배열의 이름이 주소인 이유 = 배열은 한 뭉텅이임.
다음번 자료를 찾아가기 위해서는 주소를 알야아 찾아갈 수 있음.
첫번째 칸 이후 두번째 칸을 찾는 방법 = 첫번째 칸 시작주소에서 칸 크기만큼 점프하면 된다.
칸 크기 => 배열 선언할 때의 자료형 크기(int면 4Byte) 
Index 숫자의 뜻 = 시작으로부터 몇 칸 건너뛰었느냐
배열이 0부터 시작되는 이유
첫번째 요소는 안뛰어도 되니까.


===========================

리터럴 상수 = 8Byte

val = 100; 이 val에 저장되는 방식
메모리에 100이라는 상수가 올라감
val 이라는 주소에 올라간 100을 복사해서 넣음

생성과 동시에 초기화 하는 방식
val = 0;  메모리에 val 이라는 공간을 할당하면서 동시에 0 을 저장한다.

=> 생성과 동시에 초기화 하는것과 생성 후 값을 넣는 것은 작동방식에서 차이가 있다.



float f = 3.14; 라고 하면, 4바이트의 float 안에 8바이트의 3.14 라는 리터럴상수(실수) 를 넣으려고 하니 컴파일을 할때 워닝이 생긴다.

float f = 3.14f;  에서 f의 뜻 : 리터럴상수 3.14를 4byte로 받아와서 저장하겠다.


========================
코딩을 할 때, 프로그래머가 쉬워야 한다.
코딩, 유지보수 등 모든 부분에 대해서.
그걸 고려해서 짜야함.




============================
위의 경우, for문을 8번 돌리기 위해서 i=1부터 시작하여 9까지 돌았다.

아래의 경우, for문을 8번 돌리기 위해 i=0 부터 시작해 8까지 돌린 후, i에 +2를 해주었다.

어느게 더 좋을까?



===================

#include <stdio.h>
#define MAX_LEN 5		// #전처리기(Pre-Processing) - 컴파일 단계에서 컴파일 시작 전에 전처리기 먼저 처리한다. -> 소스코드 읽기 전에 먼저 읽음
						// define = 치환 방식으로 동작한다


void main() {

	// 배열(Array) : 같은 형식의 데이터들이 연속적으로 들어가있는 구조
	// 자료구조(DataStructure)와 알고리즘
	// 배열의 요소(Element)
	// arr[Index] - 순차적으로 Index가 한 칸씩 증가하니 반복문과 같이쓰면 효율적이다.

	printf("\n==== 배열 선언 ===============\n\n");

	int arr[5]; // int 5개짜리 묶음의 배열 선언

	arr[0] = 10;	// 0번 칸에 10을 저장
	arr[1] = 20;	// 1번 칸에 20을 저장
	arr[2] = 30;	// 2번 칸에 30을 저장

	for (int i = 0; i < 5; ++i) {
		printf("%d번째 칸 : %d\n", i, arr[i]);		// 배열에 저장한 값 출력해보기
	}

	// 여기서 값을 돌려보면 4,5번 칸에 쓰레기값이 들어있다. 초기화 필요. (생성과 동시에 초기화 하는것이 좋다. 다른 변수들도 모두 동일)

	printf("\n==== 생성과 동시에 초기화 ===============\n\n");

	int arr_2[5] = { 0, };	// 생성과 동시에 초기화. 하나만 초기화해도 나머지 칸은 0으로 들어간다.

	arr_2[0] = 10;
	arr_2[1] = 20;
	arr_2[2] = 30;
										// 배열을 순회한다 = 배열 요소(Element)를 한바퀴 돌린다
	for (int i = 0; i < 5; ++i) {	
		printf("%d번째 칸 : %d\n", i, arr_2[i]);
	}

	printf("\n==== 배열 크기 확인 ===============\n\n");

	printf("arr size : %d Byte\n", sizeof(arr));		// 정적 배열인 경우 sizeof 가능.

	printf("\n==== 배열 주소 확인 ===============\n\n");

	printf("arr 배열의 이름에 저장된 값 : %p\n",arr);					// 배열의 이름에 저장된 값 알아보기

	for (int i = 0; i < 5; ++i) {
		printf("arr[%d]의 주소 : (%p)\n", i, &arr[i]);		// ***배열의 이름 = 배열 0번째 요소의 주소***
	}

	printf("\n==== 배열 크기 이상 접근 ===============\n\n");

	int idx = 100;
	arr[idx] = 100000;						// 선언한 부분을 넘어서는 위치에 주소로 접근이 가능은 하지만, 그 주소에 어떤 값이 들어있는지 모르니 조심
	printf("arr[100] = %d\n", arr[idx]);	// 배열 선언, 접근을 할 때 주소를 꼭 주의할 것

	
	printf("\n==== 배열 선언 조건 ===============\n\n");
	// 배열 선언시 Index는 상수인 정수만 가능.
	
	//int floatArr[3.5f]; // index는 소숫점이 들어갈 수 없다.(당연)
	//int len = 5;
	//int varArr[len];	// 배열 선언할 때 배열의 크기는 변수로 선언 불가능하다.
	//char len_c = '5';
	//int charArr[len_c];	// 역시 안된다.
	//int charArr['5'];	// 이건 된다. why? => '5' 는 아스키코드로 다른 숫자를 뜻하기 때문. 
						// (그런데 그 숫자는 5 가 아니기 때문에 원하는 결과는 얻지 못할 것. 하지말자)


	//// 상수(Constant) - 바꿀 수 없는 수

	//const int val = 10;		// 자료형 앞에 const를 붙이면 상수화 된다.
	//val = 100;				// val은 상수가 되었기 때문에, 값 변경이 불가능하다.
	//int constArr[val];		// 하지만 태생이 변수인 놈을 상수화(잠금장치) 하는것일 뿐이기 때문에, 선언이 불가능함. case 문에서도 상수화된 변수는 안된다.

	//// 리터럴 상수(Literal Constant) - 근본부터 상수, 8Byte

	//float f = 3.14f;
	//double d = 3.14;
	//int defineArr[MAX_LEN];		// 맨 위에 전처리기에서 MAX_LEN 을 상수 5 로 정의했기 때문에, 실제 코드 내에서는 5 로 읽어져서 문제없이 선언이 된다.

	

	// 2차원 배열(다차원 배열)  -  순회하려면 2중반복문
	printf("\n==== 2차원 배열 ===============\n\n");
	int arr2D[2][3] = { { 11, 12, 13 },{21, 22, 23 } };		// 2 by 3 배열  row / collum
															// arr2D[Row][Clo]

	for (int i = 0; i < 2; ++i) {				// row가 0,1 일 때
		for (int j = 0; j < 3; ++j) {			// col이 0,1,2 일 때
			printf("[%d][%d] = [%d] / ", i+1, j+1, arr2D[i][j]);
		}
		printf("\n");
	}

	printf("\n==== 2차원 배열의 주소 ===============\n\n");

	printf("arr2D 이름 값 :      %p\n", arr2D);			// arr2D 행렬의 이름 값
	printf("arr2D[0][0]의 주소 : %p\n", &arr2D[0][0]);	// arr2D[0][0]의 주소
	printf("arr2D[0]의 주소 :    %p\n", arr2D[0]);		// 2차원배열에서 row만 있으면 역시나 주소를 값으로 가지고 있다		arr2D[0] = &arr2D[0][0]
	printf("arr2D[1]의 주소 :    %p\n", arr2D[1]);		// 첫행에 int 3개가 있으니까 12Byte 차이.						arr2D[1] = &arr2D[1][0]

	printf("\n\n\n");
	for (int i = 0; i < 2; ++i) {				// row가 0,1 일 때
		for (int j = 0; j < 3; ++j) {			// col이 0,1,2 일 때
			printf("%d (%p) / ", arr2D[i][j],&arr2D[i][j]);		// 실제 주소는 한줄로 계속 간다.(메모리에 2차원으로 할당X - 1차원 배열과 동일)
		}
		printf("\n");
	}

	printf("arr2D[0][5] : %d\n", arr2D[0][5]);	// 배열의 크기를 넘어서는 접근이지만, 건너 뛴 자리가 2차원배열의 값이 저장된 주소라서 값을 읽어올 수 있다.


	printf("\n==== 2차원 배열 예제 (9 by 9) ===============\n\n");

	int mulple[9][9] = { {0,},{0,} };			// 2차원배열 선언. 구구단을 넣을 것임으로 9 by 9 배열을 선언한다.
	for (int i = 1; i < 9; ++i) {				// 단 수. 2단 ~ 9단 > 8개 이므로 i=1에서 시작
		for (int j = 0; j < 9; ++j) {			// 피연산자. 1~9 > 9개 이므로 i=0에서 시작
			mulple[i][j] = (i+1) * (j+1);		// 2차원 배열에 결과값 대입. [0][0]에 1x1이 들어가므로 i,j에 +1을 해준다.
		}
	}

	for (int i = 1; i < 9; ++i) {				// 2단 ~ 9단 이므로 i=1에서 시작
		printf("%d단\n", i+1);					// 단 수 출력. i=1에서 시작하고 2단부터 시작하니까 단수 = i+1
		for (int j = 0; j < 9; ++j) {			// 피연산자
			printf("%d * %d = %d\n",i+1,j+1, mulple[i][j]); // 단수 = i+1  피연산자 = j+1  (0부터 8까지 9칸 이니까)
		}
		printf("\n");							// 1단이 끝나면(이너루프에서 탈출하면) 개행
	}
	printf("끝났습니다.\n");

	///////////////////////////////////////////////////////

	printf("\n==== 2차원 배열 예제 (8 by 9) ===============\n\n");

	int multi[8][9] = { {0,},{0,} };			// 2차원배열 선언. 구구단 2단부터 시작할 것이므로 8 by 9 로 만들어봄
	for (int i = 0; i < 8; ++i) {				// 단 수. i = 0 ~ 7 인데 2 ~ 9 단이므로 i+2를 해줄 생각.
		for (int j = 0; j < 9; ++j) {			// 피연산자. 1~9 총 9개
			multi[i][j] = (i + 2) * (j + 1);	// 2차원 배열에 결과값 대입. [0][0]에 2x1이 들어가므로, i+2, j+1
		}
	}

	for (int i = 0; i < 8; ++i) {				// 2 ~ 9 단으로 총 8개 반복
		printf("%d단\n", i + 2);					// 단 수 출력. i = 0일때 2단이므로 i+2
		for (int j = 0; j < 9; ++j) {			// 피연산자
			printf("%d * %d = %d\n", i + 2, j + 1, multi[i][j]);	// 단수 = i+2  피연산자 = j+1
		}
		printf("\n");							// 1단이 끝나면(이너루프에서 탈출하면) 개행
	}
	printf("끝났숑.\n");



}










===============================
printf("\n==== 2차원 배열 예제 (9 by 9) ===============\n\n");

	int mulple[9][9] = { {0,},{0,} };			// 2차원배열 선언. 구구단을 넣을 것임으로 9 by 9 배열을 선언한다.
	for (int i = 2; i < 10; ++i) {				// 단 수. 2단 ~ 9단 > 8개 이므로 i=1에서 시작
		for (int j = 0; j < 9; ++j) {			// 피연산자. 1~9 > 9개 이므로 i=0에서 시작
			mulple[i][j] = (i) * (j+1);		// 2차원 배열에 결과값 대입. [0][0]에 1x1이 들어가므로 i,j에 +1을 해준다.
		}
	}

	for (int i = 1; i < 9; ++i) {				// 2단 ~ 9단 이므로 i=1에서 시작
		printf("%d단\n", i+1);					// 단 수 출력. i=1에서 시작하고 2단부터 시작하니까 단수 = i+1
		for (int j = 0; j < 9; ++j) {			// 피연산자
			printf("%d * %d = %d\n",i+1,j+1, mulple[i][j]); // 단수 = i+1  피연산자 = j+1  (0부터 8까지 9칸 이니까)
		}
		printf("\n");							// 1단이 끝나면(이너루프에서 탈출하면) 개행
	}
	printf("끝났습니다.\n");