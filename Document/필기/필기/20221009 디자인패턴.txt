디자인 패턴 
반복되는 패턴처럼 자주 나타나는 클래스 간의 관계를 맺는 방법


왜 올바른 관계를 맺어야 하는가?
<SOLID> 
1. 클래스는 최소한의 단위기능을 가진다.
2. 큰 기능은 이러한 단위기능을 가지는 클래스들 간의 관계를 통해 개발된다.

이러한 조건을 만족하면 
3. 꼭 필요한 것들만으로 구성된 최적화된 소프트웨어 개발 가능
4. 문제 발생 시 최소한의 코드 수정으로 유지보수가 용이하다.
5. 기존 기능에 영향을 주지 않고, 새로운 기능 추가가 용이하다.


디자인패턴은 외우는 것이 아니라 이해하는 것이다.
그대로 똑같이 따라할 필요도 없고, 패턴을 쓸 줄 안다고 무조건 그 패턴을 사용할 필요도 없다.
필요하면 쓰는거임


Iterator 패턴
동일한 형태의 데이터항목을 여러가지 가지고 있는 것을
Container, 혹은 Aggregator 이라고 한다.
Aggregator의 구성 데이터를 하나씩 가져와야 할 때, Aggregator의
종류에 따라 그 방법이 다를 수 밖에 없는데, 이를 하나의 통일된 방법
으로 가져오기 위해 사용할 수 있는 패턴

UML 
다이아몬드 : 붙은쪽이 상대방을 소유한다.
검정색 : 소유한 쪽이 수명이 다하면 소유당한쪽도 사라진다
하얀색 : 별개

Strategy 패턴
프로그램 실행때 모드에 따라 기능이 바뀔 때 사용한다.
모드에 따른 각 기능들을 각각 모듈화하여 두고, 모드에 따라
모듈을 갈아끼우는 식으로 구현한다.
Setter를 이용해 모듈을 선택해주기만 하면 그에 맞는 모듈이 작동한다.
델리게이트로 동작할 함수 바꿔치기 하는거랑 비슷함
모듈은 독립적이고, 상호 교체가 가능하다.



State 패턴
Strategy랑 비슷하다.
전략패턴은 동일한 어떤 동일한 틀 안에있는 특정작업의 방식, 모드를 바꿔 줄 때(이미지검색, 글 검색 등)
State패턴은 TV TurnOn, Off 등 특정 상태 자체, 그리고 그 특정 상태일 때 할 일을 모듈화해서 지정한다.
TV TurnOn Off 만 받게 만들어두고, TV TurnOn 상태일 때는 그에 맞는 액션을 하게 하는것 



Command 패턴
Strategy와 비슷.
커맨드패턴은 하는 일 자체가 달라질 때 사용한다.
여러 목록을 차례로 실행시킬 수도 있다.
Bed > Action : Sleep
TV > Action : TurnOn
ResetSwitch > Action : Reset
이런거



Adapter 패턴
어댑터
내가 Action 이라고 말하면, 너는 Play 로 알아들으면 되 라는뜻
Action(){
    Play()
}



Proxy 패턴
가벼운 작업 + 무거운 작업 이 있을 때(유튜브 썸네일 같은거)

가벼운작업 / 무거운작업 을 모두 가지는 인터페이스 선언
가벼운 클래스는 인터페이스 상속받아서 가벼운건 직접 구현
무거운 작업이 호출 되었을 때, 무거운 클래스를 호출
무거운 클래스에는 정상적으로 작업 구현



Facade 패턴
말 안해도 많이 쓰는 패턴.
Player 스크립트에 Update 보면 
마우스 입력값 받아와서 카메라에 보내주고
카메라 회전값 받아와서 모델회전에 보내주고
키보드 입력값 받아와서 MoveAgent에 보내주고
이런걸 클래스 하나 만들어서 알아서 처리하게 만드는 것



Template method 패턴
같은 형식을 지닌 특정 작업들의 세부방식을 다양화하게 할 때

서브웨이(){
    빵 고르기();
    야채 고르기();
    패티 고르기();
    빵 고르기();
}

으로 만드는데,  빵 은 무슨빵, 야채는 무슨야채, 패티는 무슨패티 이런걸 상속받아서 각각 바꿔주기만 하면 각각 별개의 서브웨이가 나온다.



Decorator 패턴
기본 기능에다가 추가되도록 하는거
전투기 공격 + 아이템 먹으면 레이져도 같이쏨 + 아이템 먹으면 미사일도 같이 쏨
객체가 생성자 변수로 다른 객체에 인자로 들어간다.
그 생성자를 받은 객체는 그 새로 생성된 객체에다가 기능을 추가한다.



Factory 패턴
객체를 생성해주는 클래스
1. 객체를 생성하는 코드를 여러군데 둔다면, 생성자가 변경된다던지 했을 때 여기저기를 다 고쳐야 한다. 팩토리를 쓰면 팩토리 한군데만 고치면 됨

2. 다른 개발자가 어떤식으로 객체가 생성되는지는 모르겠고, 일단 
    객체의 조건만(스위치, 토글 등등) 넘겨주면 객체가 나온다.

Decorator 패턴과 결합하면, FactoryDecorator 클래스를 만들 수 있다.
비행기 객체와 장착을 원하는 무기조건을 인자로 넘겨주면, 
뭐 어케하는지는 모르겠지만 FactoryDecorator 안에서 그 무기를 장착해서 다시 넘겨줌.



Abstract Factory 패턴
공장을 찍어내기 위한 패턴.



Mediator 패턴
콜백을 담당하는 클래스
콜백 받을 클래스 : ModeListener 인터페이스 상속받고 콜백을 받을 함수 선언

콜백 담당 클래스 : List<ModeListener>와 addListener 함수 선언
메인에서 addListener에 콜백받을 클래스를 거기다가 싹 다 집어넣음.

그후에 onCallback 을 호출하면 List<ModeListener> 에 들어있는 모든애들의 콜백함수를 실행시킨다. 



Composite 패턴
폴더, 파일 관리
포함하는놈, 포함되는놈을 같이 관리하고싶을 때 사용


재귀함수
꼬리재귀최적화 확인