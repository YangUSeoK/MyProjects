오후 2:19 2022-08-01


.sln = 솔루션파일 
(작업했던 맨 마지막 화면이 그대로 실행됨)

.vcxproj = 프로젝트파일

.vcxproj.filters = 프로젝트의 필터 정보(메타정보)
.vcxproj.user = 프로젝트의 유저 설정 정보

.c = 소스파일


32bit = x86 에서 86은 286 386 486할때 그 86에서 나왔다.

Debug, Release, 폴더 안의 .exe 파일 = 프로그램 실행파일

Debug= 디버그 정보를 담고 있어서 용량이 많다.
개발하는 중에 나오는 파일이라 메모리 관련 등 검사가 조금 여유롭다

Release = 디버그정보가 빠져서 용량이 적다
마지막 검사라 빡세게 한다.

===============================

반복문(Loop)

for(초기화; 조건문; 증감문)

초가화 : 맨 처음 시작할 때 한번만 들어간다.
처음 값을 지정

조건문 : 이 조건이 참이면 반복문을 실행
(주의할 점 : 초기화 후 조건문 검사 후 실행으로 들어간다.)
for(i=5; i<5;i++) 이면 실행이 안되고 나오는 것에서 알 수 있다.

증감문 : 반복문을 실행하고 난 후 실행된다.
================================
for문 = 조건이 명확할 때

while문 = 조건이 애매하거나 연산이 많을 때

do~while문 = 무조건 1회를 실행하고 조건 검사


2중 for문 
이너루프가 다 끝나고 아우터로 간다. (절차지향)


3중 이상은 너무 느려지고, 수학적으로 계산하여 훨씬 간단하게 줄일 수 있으므로, 실제로는 3중 이상은 거의 쓰이지 않는다.





2011년 이전 C에서는 변수를 사용하기 위해선 코드 상위에 변수선언을 모아서 한군데에 해야 함.
(메모리에 올린 후 읽다 말고 다시 다른 정보를 메모리에 올리는 것이 불가능했음)

2011년도 부터 가능하도록 변경됬다.
이러면서 가능해 진 점
int i;
for(i = 0; i < 5; i++)  => for(int i = 0; i < 5; i++)
변수선언과 초기화를 동시에 가능.

===============================
단항연산자 ++, --
i++과 --i 의 차이점
선증가, 후증가의 차이점(타이밍)
그 변수가 참조되는 타이밍 이전에 증가되냐, 이후에 증가되냐의 차이.
++i 는 i에 들어있는 값을 불러올 때 1을 증가시킨 후 사용한다.
i++는 i를 사용한 후 1을 증가시킨다.

tip)선증가가 후증가보다 속도가 빠르다.
왜냐하면 참조 이후 다시 그 값을 찾아서 올려야 하므로. => 게임,엔진 등을 만들 때에는 같은 조건이라면 선증가를 많이 사용한다.
선증가를 마음놓고 사용할 수 있는 곳 중 하나가 for문의 증감문이다.


================================
for문 = 조건이 명확할 때

while문 = 조건이 애매하거나 연산이 많을 때

do~while문 = 무조건 1회를 실행하고 조건 검사


=============================
변수의 Life-Cycle - 메모리에 올라갔다 내려올 때 까지

메모리에 올라갈 때 = 변수 선언을 할 때
메모리에서 내려갈 때 = 그 선언된 지역(중괄호) 가 끝날 때

>> 변수선언을 for문 위에서 한다면 for문이 끝나도 Life-Cycle이 살아있다.
for문 안에서 변수선언을 하면 for문이 끝나면 Life=Cycle이 죽는다.

반복만을 위해서는 for문 안에서 선언을, 반복문 이후에도 그 변수를 사용할 것이라면 for문 밖에서 선언해야 한다.


지역변수(Local-Variables)의 Life-Cycle은 지역 내에서만 존재한다.
변수가 호출되었을 때, 같은 지역의 변수가 최우선적으로 호출된다.







==========================
#include <stdio.h>

int main() {
	//// 반복문(Loop)
	//
	//// for문 - 조건이 명확할 때(언제 시작해서 언제 끝날지 정확히 알 때)

	// //for (초기화; 조건문; 증감문)
	// //초기화 : 처음 값을 지정. 맨 처음 반복문을 시작할 때 한 번만 들어간다. i,j,k 를 많이쓴다.
	// //조건문 : 이 조건이 참이면 반복문을 실행. 거짓이면 반복문을 탈출한다. (주의할 점 : 초기화 후 조건문 검사 후 실행으로 들어간다.)
	// //증감문 : 반복문을 실행하고 난 후 실행. 반복문에 쓰이는 변수 값을 변화시킨다. 이후 조건문으로 돌아가 루프를 반복한다.
	// //int i = 0; 원래는 변수를 따로 선언해주어야 했으나, 2011년도부터 for문 내에서 변수선언과 초기화 동시에 가능.

	//printf("\n==== for  =================\n\n");

	//for (int i = 0; i < 5; ++i) {   
	//	printf("%d\n", i);
	//}


	//printf("\n==== for문 내에서 int i = 0, j = 0; 가능 =================\n\n");
	//for (int i = 0, j = 0; i < 5, j < 4; ++i, j+=3) {			// 조건이 여러개라도, 하나만 out되면 끝난다. => or
	//	printf("i = %d  j = %d\n", i, j);						// i<5는 만족하더라도 i<4가 아니니까 끝난다.
	//}
	//printf("\n==== for문 내 초기화 생략 가능 =================\n\n"); 
	//int i = 0;
	//for (; i < 5; ++i) {
	//	printf("i = %d\n",i);
	//}

	//printf("\n==== 무한루프 탈출법 =================\n\n");

	//int j = 0;
	//for (;;j+=3) {				// 무한루프. 조건문이 없기 때문에 탈출을 하지 못하고 평생 돈다.
	//	printf("%d\n", j);
	//	if (j > 30){
	//		printf("break를 만났습니다.\n");
	//		break;				// 무한루프를 탈출하기 위해서는 탈출문이 필요하다.
	//	}		
	//}


	//// while문 - 조건이 애매하거나 연산이 복잡할 때 / 탈출 조건이 복잡할 때 (언제 시작해서 언제 끝나는지 정확히 모를 때)
	//printf("\n==== while ==============\n\n");
	//
	//// while(조건) 
	//int w = 0;			// 변수선언을 밖에서 해줘야 함.
	//while (w < 5) {		// 조건이 참이면 실행
	//	printf("%d\n", w);
	//	++w
	//		;			// 증감문을 직접 적어줘야 한다. 아니면 무한루프임.
	//}


	//// do while문 - 먼저 1회 실행하고 그후에 조건 검사를 한다. 조건이 맞지 않아도 1회는 반드시 실행.
	//printf("\n==== do~while ==============\n\n");
	//int d = 0;					// 변수선언 밖에서
	//do {
	//	printf("%d\n", d);
	//	++d;
	//} while (d < 5);			// 실행 후 조건검사
	


	//// 반복문 중첩 (2중 for문)
	//printf("\n==== 반복문 중첩(구구단 만들기 예제) ==============\n\n");
	//for (int i = 2; i < 10; ++i) {							//2~9단 이니까 초기값 2, 조건 i<10 설정. i<=9 도 상관없다.
	//	printf("%d단\n",i);
	//	for (int j = 1; j < 10; ++j) {
	//		printf("%d * %d = % d\n", i, j, i * j);
	//	}
	//	printf("\n");
	//	}

	
	printf("\n==== 반복문 하나로 (star pyramid 예제) ==============\n\n");

	int targetFloor = 0;
	printf("\n목표 층수를 입력하세요.\n");
	scanf_s("%d", &targetFloor);

	for (int floor = 0, starcount = 0;;) {	// 층 수, 별 개수 선언 후 0으로 초기화, 무한루프
		
		//printf("i = %d, starcount = %d\n",i,starcount);
		

		if (floor > starcount) {			// 층 수가 별 개수보다 크다면
			printf("*");					// 별을 그리고 별 개수++
			++starcount;

		}
		else if (floor == starcount) {		// 층 수와 별 개수가 같다면
			printf("\n");					// 개행 후 층수++, 별 수 초기화
			++floor;
			starcount = 0;
		}
		else {								// 오류처리
			printf("\n오류\n");
			break;
		}

		if(floor == targetFloor+1){			// 층 수가 목표층수와 같으면 break;
			printf("\n완성되었습니다.\n");		// floor은 0부터 시작이니까 targetFloor에 +1
			break;
		}
		

	}

	for (int i[10][10]={0,};;) {

	}
	
	




	//// 단항연산자 
	//// i++ : 후증가 연산자  (i--)
	//// ++i : 선증가 연산자  (--i)
	//printf("\n==== ++i와 i++의 차이점 =================\n\n");
	//int val = 10;
	//printf("value++ : %d\n", val++);
	//printf("value : %d\n", val);
	//printf("++value : %d\n", ++val);
	//printf("value : %d\n", val);

	//// 복합연산자 ++, --, +=, -=, *=, /=, %=
	//// int var = 0;
	//// var += 3;		var = var + 3
	//// var -= 4;		var = var - 4
	//// var *= 2;		var = var * 2
	//// var /= 3;		var = var / 3
	//// var %= 2;		var = var % 2



	//printf("\n==== 변수의 Life-Cycle =================\n\n");
	//// 지역변수(Local Variables)
	//// 지역변수의 Life-Cycle은 지역 내에서만 존재한다.
	//int local = 100;
	//printf("괄호 밖 local : %d\n", local);
	//printf("괄호 밖 local 의 실제 주소값 = %x\n", &local);
	//{
	//	int local = 50;
	//	printf("괄호 안 local : %d\n",local);				//같은 지역의 변수가 최우선적으로 불려온다.
	//	printf("괄호 안 local 의 실제 주소값 = %x\n", &local);
	//	local -= 40;
	//	printf("괄호 안 local : %d\n", local);
	//}
	//printf("local : %d\n", local);
	
	



	printf("\n============================\n");
	return 0;
}










