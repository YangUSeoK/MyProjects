카메라, 조명


Local은 원래 자기혼자 있었음
다른 Local 를 배치하고 Local끼리의 관계를 나타내기 위해 
World 라는게 등장함.

World 에서 어떤 Local의 시야 를 표현하기 위해 Camera 가 등장.
(위치, 회전 필요)

카메라 행렬 : 
카메라가 움직이는 반대방향으로 물체가 움직이는 것으로 보인다.


물체의 위치, 각도, 스케일을 나타내는 행렬은 매 프레임마다 계산되어 새롭게 표시된다.
위치가 변한다면 변한 위치를 다시 계산하여 위치를 옮기고, 
위치가 그대로면 전에 썼던 계산식을 다시 쓴다.

=> 이 세상 전체의 위치를 옮기는 것 보다 카메라의 위치를 옮기는게 훨씬 쉽다.


FOV (Field Of View) : 위에서 봤을때 카메라 시야각 
                           요즘은 90도가 기준, 유니티는 60





3D 고정 렌더링 과정 (3D pixed Rendering pipeline)

Perspective Camera : 원근을 표시하는 카메라

절두체 (Frustum) : 원근표시
카메라 바로앞부터 그리는게 아니고, 살짝 앞 부분부터 그린다.
카메라가 인지해서 그리는 영역 (NearPlane ~ FarPlane 사이의 영역)

Projection : 투영


Orthographic Camera : 직교 카메라
원근X 2D 만들 때 씀(탑뷰 등등)



컴퓨터그래픽스 에서 가장 먼저 일어나는 최적화 
그림 그릴 때 일어남 -> 카메라가 매우 중요하다.(보이는 부분만 그림)

카메라에 안보이는 부분을 걸러내는 기법이 발달
Frustum Culling : 절두체(Frustum)를 기준으로 안쪽인지 바깥인지 
판단, 바깥쪽이면 걸러낸다.(Frustum 표면 벡터의 외적 이용)

어정쩡하게 걸쳐있는 애들 잘라내는 작업 : Culling

은면 제거, 후면 제거 (Backface Culling)
달의 뒷면은 절대 안보인다 -> 이것도 잘라냄 
카메라 방향벡터와 표면의 벡터의 내적을 하면 방향을 알 수 있다.
반대방향 제거하는 방식

차폐 제거 (Occulusion Culling)
물체 뒤에 가려져 있는 물체를 걸러낸다.


컬링 이후에 연산된 그림을 2D로 변경해줘야 한다.(모니터는 2D니까)

Clipping : 만들어진 2D 이미지를 픽셀로 찍을 때도 화면범위 바깥에 튀어나간 픽셀을 걸러낸다. (픽셀찍는 반복문 횟수를 줄임)

결국 가장 중요한건 직선을 빨리, 정확하게 긋는 것이다.
-> 어셈블리로 짰음


그래픽카드가 하는 일 : 삼각형을 존나 빨리 그려줌


3d 그래픽렌더링 순서가 고정적으로 정해져 있으므로, 누가 만들던 
그래픽이 똑같다.
그래서 만들어진것이 Shader




함수 오버로딩
함수 이름이 같아도 인자가 다르면 다른 함수로 인식
호출할 때도 인자와 맞는 함수를 호출해줌
컨트롤 시프트 스페이스 = 오버로딩 된 함수들의 인자 확인가능

오버라이딩
자식클래스에서 부모클래스의 함수를 재정의하는 것





=======================
메쉬 필터 : 형체
메쉬 렌더러 : 어떻게 그릴건지 => Material 이 여기 있는 이유


============================
컴포넌트는 전부 클래스다
컴포넌트 안에 있는 수치들은 전부 변수임.

=> 모든 컴포넌트, 모든 변수는 다 스크립트로 접근이 가능하다.



===============================
new : 동적할당

클래스 멤버 변수(함수) 를 static 으로 선언하면 객체를 안만들어도 
접근이 가능하다

객체에 접근하려면 먼저 객체를 만들어야 해서 new 를 사용해주는것
생성자를 호출하는 기능이 new

클래스가 만들어 질 때 자동으로 호출되는게 생성자
클래스 명과 똑같은데 반환형이 없다.
메모리에 올라가자마자 바로 호출됨

파괴될 때 자동으로 호출해주는게 소멸자
클래스명 앞에 ~ 가 붙음. 반환형 없다.
메모리에서 내려가기 직전에 호출됨

클래스 내에 있는 모든 데이터들이 생성되고 파괴되는 타이밍을
쉽게 관리하기 위해 생성자, 호출자


================================
True Color 
rgb 255 255 255 로 표현할 수 있는 방식 (3Byte = 24Bit)

HDR (High Dynamic Range)
255값 이상으로 표현할 수 있는 방식

=========================
Camera 컴포넌트

Clear Flags = 아무것도 없는 빈 공간에 뭘 채워넣을건지 결정
skybox : 하늘
Solid Color : 지정 색깔로 채워짐
Depth only : 깊이값만 가지고 그림을 그린다. 
Don't Clear : 클리어하지 않는다 -> 원래있던 그림이 그냥 그대로 남아있음(잔상)

Culling Mask : 이 카메라는 어떤것만 찍고 어떤것은 거른다
Projection : 투영 방법. Perspective(원근), Orthographic(직교)

FOV : Perspective 모드에서만 동작. 시야각
      : 분위기, 환경 연출에 사용(속도감)

Clipping Planes : Near Plane, Far Plane 거리 설정

Viewport Rect
전체 화면(Game View) 에서 얼마만큼을 그릴거냐 를 설정
(X,Y) : 카메라 화면 위치
(W,H) : 전체화면에서 비율로(최대화면 1,1) 설정

Depth : 위에 Clear Flags 에 있던 Depth 값
누가 먼저 그려지고 나중에 그려지는지 를 정한다.
=> Game View 에 그리는 순서. Depth 가 낮은 것 부터 그리고, 그위에 다음카메라 씬을 그리고, 그 위에 또 다른카메라 씬을 그리면서 화면에 출력해준다.
그중에 Clear Flages 에서 Depth only 를 체크해주면 그 전에있는 화면 위에 겹쳐서 나오는 것 처럼 보인다.(스타에서 캐릭터 초상화 표시, 게임에서 메뉴 켜면 나오는 메뉴창 등 UI)
=> Rendering PipeLine 참고


Rendering Path : 렌더링 파이프라인을 어떤걸 돌릴지 설정
Legacy 붙은거 - 다 옛날거
Forward, Deferred 차이 : 조명, 그림자 처리에 대한 차이
Forward : 조명, 그림자를 계산하는 타이밍(카메라 다음)에서 계산
Deferred : 조명, 그림자 계산을 제일 마지막으로 미룬다. 퍼포먼스 up


Target Texture : 카메라가 찍고 있는 것을 Texture 로 만들어줌.
Occlusion Culling : 차폐컬링 할건지 말건지 체크

HDR (High Dynamic Range) : 사용할건지 말건지 체크

MASS : 안티얼라이징(안티앨리어싱) 
x8, x16, x32 : 주변 픽셀 8개, 16개, 32개 를 가지고 샘플링을 한다

Use Graphics Setting : Edit - Project Settings -> Graphics 에서 설정

=======================================
Audio Listener : 귀. 씬 하나에 하나만 있어야 한다.


Pysic

=============================================
Lighting
컴퓨터에서는 조명과 그림자로 따로 연산한다.
(명암, 그림자)

쉐이딩 : 빛과 그림자를 어떻게 처리할 것인가 에 대한 기술.
Flat Shading : 한 면 단위로 색깔이 달라진다.
gouraud shading : 정점 (Vertax) 단위로 색깔이 달라진다.
Phong shading : 픽셀 단위로 색깔이 달라진다.


Light 컴포넌트
Type 
Directional Light : 방향만 있는거. World 공간 전체에 동일한 방향의 빛이 들어온다. 광원의 위치는 상관X (태양)

Spot Light : 한 점에서 시작해서 일정 영역 만큼만 비춘다.
광원 위치, 방향, 세타값(범위각), 영역의 원 둘레, 빛의 감쇠 등등 필요
Range : 조명 거리(빛 감쇠)
Spot Angle : 세타값(범위각), 최대 179


Point Light : 한 점에서 시작해서 전 방향으로 일정 거리만큼 발광
Range : 조명 거리

Area(baked only) : 조명이 변하지 않는 경우, 미리 계산된 빛만 가지고 처리한다.(연산처리 낮춤)
Object 이름 옆에 static 으로 설정하면, 안움직이는 물체로 인식해서 게임 시작 전에 계산한다.

volumetric Light : Pysical Based Rendering(현실세계처럼 렌더링하는 기술) 를 쓰면 가능. 


Intensity : 조도



========================================
3D연산에서 삼각형을 쓰는 이유

삼각형의 꼭지점 : Vertex
3D 최소 연산단위 : 삼각형
한 평면에 면을 구성하기 위해 필요한 최소 조건이 삼각형이다.

Flat Shading
한 면마다 색깔이 다르므로, 결국 삼각형 마다 색깔이 다르다.

A-C 벡터 = C가 A로 향하는 벡터
B-C 벡터 = C가 B로 향하는 벡터
이 두 벡터를 외적하면 : 이 면에 수직하는 normal 벡터가 나온다.

이 normal 벡터와 조명의 벡터를 가지고 내접하면 물체의 각도가 나온다. 
정면일 때 : 100%
점점 각도가 생기면서 조금씩 어두워지다가
90도 일 때 부터는 아예 그려지지 않는다.


gouraud Shading
정점의 normal 벡터와 조명의 벡터를 가지고 계산하면 더 세밀한 
처리 가능
정점이 가지고 있는 정보 : normal vector, uv 등


Phong Shading
픽셀 단위로 처리 가능.


Lighting 계산이 끝나고 나면 : 명암처리는 할 수 있다.
하지만 그림자는 처리가 안됨. 



그림자처리 
Plane Shadow : 90도 기준 양 끝점을 기준으로 바닥에 그림을 그린다
이건 계단같은데서는 그림자가 안생긴다(바닥에 색깔칠하는거니까)

Volumetric Shadow : Volumetric Light 처럼 그림자를 볼륨있게 계산

Shadow mapping : 계단같은거를 만나면 거기도 색칠

레이트레이싱 : 빛이 반사되는것도 처리해서 만듬