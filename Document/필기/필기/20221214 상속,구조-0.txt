오후 6:13 2022-12-14

매니저를 쓰는데 정해진 방법론이나 이런게 있는건 아니다.
왜 관리를 해야하는지, 왜 필요한지를 알고 필요할 때 쓰면 됨


플레이어랑 Enemy는 보통 공통된 내용을 많이 가지고 있는 경우가 많음. = Charactor 클래스 상속


상속을 쓰는 이유
1. 소스코드 재활용
2. 추상화 프로그래밍(다형성) >> 객체지향의 꽃
상속이 처음 나왔을 때는 추상화프로그래밍이 없었다. 


생각해봐야 할 점 >> 기능이 확장이 되는부분이 있는지
플레이어와 Enemy가 완전히 똑같다면 : 상속을 받을 필요가 없다.
그게 아니라 Charactor가 가지고 있는거 + 확장되는 부분이 있는지 를 먼저 봐야한다.


Charactor를 관리하는 기능을 만든다
-> 플레이어와 Enemy가 Charactor을 상속받는다
-> 플레이어와 Enemy를 Charactor 관리기능으로 관리하는게 가능
>>> 상속을 쓴다는것 자체가 Charactor관리기능으로 다 관리하겠다는 것이므로, Charactor 관리기능만 가지고도 프로그램이 돌아가야 한다.


어디까지 추상적으로 만들것인지가 핵심
프로그램의 메인 코어부분에는 Player나 Enemy 같은 세부적인 부분이 없어야 한다.


매개변수 없이 처리하는 함수 : 그 클래스에서밖에 쓸 수 없다.
매개변수를 받아서 처리하는 함수 : 바깥에서도 쓸 수 있다.

다른 몬스터나 다른 플레이어 등이 들어와도 똑같이 작동할 수 있도록 하는것이 확장성

인벤토리에 아이템이 들어오는데, 나중에 무기가 추가되더라도 코드수정 없이 무기도 인벤토리에 들어가야 한다.



클래스를 만드는 이유
정보와 기능을 하나로 묶어서 혼자서 돌아가는 객체를 만들기 위함
이를 위해서 각 클래스는 자기를 관리하는 정보와 기능만 가지고 있어야 함
내 정보를 바꿀 수 있는 권한는 스스로밖에 없다.


Player.transform 으로 접근하는 순간, 밖에서 내 위치를 바꾸는거니까 잘못된거임
변수에 바로 접근하는건 무조건 잘못된거다.
Player.Move() 를 호출하고, 그 Move 안에서 Player는 스스로를 직접 움직여야 한다.

게임오브젝트를 통해서 직접 뭔가를 하는게 하나도 없어야 한다. 
그 게임오브젝트를 관리하는 스크립트를 붙이고, 그걸 호출해서 관리해야 함.

큐브의 콜라이더를 껐다켰다 하기 위해서는 Cube.GetComponent<BoxCollider>().enabled 로 하지말고(이게 게임오브젝트를 통해서 뭔가를 관리하는 것)
Cube.GetComponent<Cube>(). 로 스크립트에 접근한 후에, OnCollider() / OffCollider() 를 호출해야 한다.

캡슐화가 제일 중요함.

상속을 왜 써야하지 라는 생각이 들었다면, 스크립트를 통해 관리한게 아니라 게임오브젝트를 통해서 관리를 하고있던 것이다.
이걸 스크립트를 통해서 제어를 해야 상속을 통해서 Charactor관리를 하는 힘이 나온다.

벡터클래스를 만드는 등의 경우(애초에 목적이 값을 바꾸는 일을 하는 클래스) 외에는 public변수를 쓰는 일은 없어야 한다.

위치를 참조하고 싶다면 관리하는 스크립트를 만들고 그 스크립트에서 GetPosition() 함수를 만들어 참조한다.

컴포넌트는 클래스이기 때문에, 참조복사가 된다. 절대로 이 값을 바꿀 수 있는 권한을 외부에 내보내면 안된다. 
왜 이상하게 움직이지? 같은 경우, 딱 한군데에서만 관리하면 거기만 찾아보면 된다.

충돌체크 같은거 할때도 당연히 그 부딪힌놈의 스크립트를 가져와서 관리해야 한다.
그런데 이 경우에 누구랑 부딪힐지를 모르니까 부딪힐 수 있는 모든놈들의 GetComponent를 다 해봐야한다.
이걸 편하게 하기위해 상속을 쓴다

클래스 내에서 외부클래스의 GetComponent를 하는 일이 한번도 없도록 만들어보자.

Awake 안에서 GetComponent를 할 때 타이밍이 꼬일 수 있다. 제인 좋은 방법은 실제로 만들어서 붙여주는것. (대신 미리 세팅을 못해두는 단점이 있다)

매니저 급에서는 추상적으로 코드가 짜져야 한다.
Enemy 등 제일 밑단에서만 구체적으로 짜면 됨.

멤버변수로 가지고 있는 값이 있다면, 매개변수로 받지말고 멤버변수로 접근해야 한다. 매개변수로 다른 값이 들어올 수도 있기 때문.

멤버변수 컨트롤 할 때 this 붙이는 습관 들이기


콜백이랑 Update에서 검사하는 방법
콜백이 무조건 좋은 것 갈지만, 여러 Update에서 동시에 뭔가가 일어나면 문제가 생길 수도 있다.

아무때나 발동해도 꼬일 일이 없는 이벤트면 델리게이트로 콜백받는게 좋음.

뭔가를 처리하는 도중에 이벤트가 발동되면 꼬일 수 있는 경우에는 Update에서 검사하는게 더 명확하고 편하다.

매니저는 이런 과정을 통제하는 것도 필요하다.
